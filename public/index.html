<html>
<head>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js" type="text/javascript" charset="utf-8"></script>
  <script src="javascripts/AStar_memtronic.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript" charset="utf-8">
    
    var corpses = [];
    
    var SoldierManager = function(){
      var self = this;
      var id = 0;
      var soldiers = [];
      var soldierHash = {};
      var soldierTypes = [
				{
				 name: 'lightInfantry',
				 speed: 2,
				 color: '#8ae5f7',
				 health: 50,
				 size: 10,
				 bounty: 1 
				},
				{
				 name: 'heavyInfantry',
				 speed: 2,
				 color: 'grey',
				 health: 200,
				 size: 16,
				 bounty: 2
				},
				{
				 name: 'bike',
				 speed: 3,
				 color: 'blue',
				 health: 70,
				 size: 10,
				 bounty: 1
				}
				// 2: 'bike',
				// 4: 'helicopter'
			];
			
      // probably needs optimising
      this.allSoldiers = function(){
        var myArray = [];
        for( i in soldierHash){
          if(soldierHash[i] != null){
            myArray.push(soldierHash[i]);
          };
        }
        return myArray;
      };
      
      this.createSoldier = function(typeIndex){
        var newId = id++;
        soldier = new Soldier(startPoint, endPoint, grid, soldierTypes[typeIndex], newId);
        soldier.onReachDestination(function(){
          soldierHash[newId] = null;
          AttemptToWinGame();
          loseLife();
        })
        soldier.onDie(function(){
          soldierHash[newId] = null;
        })
        soldierHash[newId] = soldier;
        return soldier;
      };
      
      this.withinRange = function(x, y, range){
        myArray = [];
	      for (var i=0; i < mySoldierManager.allSoldiers().length; i++) {
	        var soldier = mySoldierManager.allSoldiers()[i];
	        if (soldier.getCurrentPoint()[0] >= x-range && 
	              soldier.getCurrentPoint()[0] <= x+range &&
	            soldier.getCurrentPoint()[1] >= y-range && 
	              soldier.getCurrentPoint()[1] <= y+range ){
	          myArray.push(soldier);
	        }
	      };
	      return myArray;
      }

    };
    
    var TurretManager = function(){
      var self = this;
      var id = 0;
      var turretHash = {};
      var turretTypes = [
        {
          name: 'machine gun',
          fireRate: 2,
          range: 2,
          color: '#555',
          damage: 1,
					cost: 5
        },
        {
          name: 'mortar',
          fireRate: 20,
          range: 4,
          color: '#999',
          damage: 20,
					cost: 15
        },
        {
          name: 'heavy cannon',
          fireRate: 50,
          range: 4,
          color: '#999',
          damage: 100,
					cost: 15
        },
        {
          name: 'glue gun',
          fireRate: 20,
          range: 1,
          color: 'green',
          damage: 0,
					cost: 5,
					hitCallback: function(soldier, myFrameNum){
					  soldier.slow(myFrameNum + 100);
					}
        }
      ]
      
      // probably needs optimising
      this.allTurrets = function(){
        var myArray = [];
        for( i in turretHash){
          if(turretHash[i] != null){
            myArray.push(turretHash[i]);
          };
        }
        return myArray;
      };
      
      this.createTurret = function(position){
        var newId = id++;
        var myTurret = new Turret(position, turretTypes[currentTurretIndex], newId);
        turretHash[newId] = myTurret;
        money -= myTurretManager.cost(currentTurretIndex);
        return myTurret;
      };

			this.cost = function(index) {
				return turretTypes[index]['cost']
			};
			
			this.getTurretTypes = function(){
			  return turretTypes;
			}
    }
    
    var Grid = function(canvas_id, grid) {
	    var canvas = document.getElementById(canvas_id)
	    var ctx = canvas.getContext('2d'); 
	    var width = grid[0].length;
	    var height = grid.length;
	    var gridXInterval = canvas.width / width;
	    var gridYInterval = canvas.height / height;
	    var gridHeight = canvas.height;
	    var gridWidth = canvas.width;
      var highLight;
      var result = AStar(grid, startPoint, endPoint, "Manhattan");
	    
	    var draw = function(){
	      ctx.clearRect(0,0,gridWidth, gridHeight);
		    ctx.beginPath();
		    ctx.strokeStyle = '#aaa';
		    ctx.lineWidth = 1;
		    for (var i = 0; i < width; i++) {
		      ctx.moveTo(i* gridXInterval, 0);
		      ctx.lineTo(i* gridXInterval, gridHeight)
		    };
		    for (var i = 0; i < height; i++) {
		      ctx.moveTo(0, i*gridYInterval);
		      ctx.lineTo(gridWidth, i*gridYInterval);
		    };
		    ctx.stroke();
        drawCorpses();
		    drawStartAndEnd();
        drawTurrets();
        // drawPath();
        drawSoldiers();
        drawHighLight();
        drawBits();
        drawTerrain();
		  };
		  
		  // called from the setinterval
		  this.public_draw = function(){
		    draw();
		  }
		  
		  var drawHighLight = function(){
		    if(highLight && !nuking){
		      // check there is money
  		    if(money < myTurretManager.cost(currentTurretIndex)){
  		      var color = '255, 0, 0';
  		    } else {
  		      var color = '0, 255, 0';
  		    }
          drawCircle(
            highLight[0],
            highLight[1],
            'rgb(' + color +')'
          );
          r = myTurretManager.getTurretTypes()[currentTurretIndex]['range'] * 2 + 1
          drawCircle(
            highLight[0],
            highLight[1],
            'rgba('+color+', 0.3)',
            r
          );
		    } else if (highLight && nuking){
		      var color = '255, 255, 0';
		      drawCircle(
            highLight[0],
            highLight[1],
            'rgba('+color+', 0.3)',
            nukeRadius * 2 + 1
          );
		    }
		  };
		  
		  var drawCircle = function(x, y, mycolor, radius){
		    radius = radius ? radius : 1
		    ctx.beginPath();
		    ctx.fillStyle = mycolor;
        ctx.arc(
          x * gridXInterval + gridXInterval / 2, 
          y * gridYInterval + gridXInterval / 2,
          radius * gridXInterval / 2,
          0,
          Math.PI*2,
          true
        );
        ctx.fill();
		  }
		  
		  var drawTurrets = function(){
        for(var i =0; i < myTurretManager.allTurrets().length; i++){
          var turret = myTurretManager.allTurrets()[i]
          drawCircle(
            turret.getPosition()[0],
            turret.getPosition()[1],
            turret.getColor()
          );
        }
        // gonna do this in 2 loops for now - wasteful
        for(var i =0; i < myTurretManager.allTurrets().length; i++){
          var turret = myTurretManager.allTurrets()[i]
          connectTarget(turret);
        }
		  }
		  
		  var connectTarget = function(turret){
		    var soldier = turret.targettedSoldier();
		    if (soldier){
          ctx.beginPath()
          tx = turret.getPosition()[0] * gridXInterval + gridXInterval/2
          ty = turret.getPosition()[1] * gridYInterval + gridYInterval/2
          ctx.moveTo(tx, ty )
          sx = soldier.getCurrentPosition()[0]
          sy = soldier.getCurrentPosition()[1]
          var coords = getNewCoords(tx, ty, sx, sy, 15);
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;          
          ctx.lineTo(coords[0], coords[1]);
          ctx.stroke()
          // draw the fire
          if(turret.isFiring()){
            ctx.beginPath()
            radius = 5
            // flame
    		    ctx.fillStyle = 'orange';
            ctx.arc(
              coords[0], 
              coords[1],
              radius,
              0,
              Math.PI*2,
              true
            );
            ctx.fill();
          };
        }
		  }
		  
		  var getNewCoords = function(x1, y1, x2, y2, radius){
		    var dx = x2 - x1;
        var dy = y2 - y1;
		    var theta = Math.atan2(dy, dx);
        return [
          x1 + (Math.cos(theta) * radius),
          y1 + (Math.sin(theta) * radius)
        ]
		  }
		  
		  var drawStartAndEnd = function(){
		    ctx.fillStyle = 'yellow';
        ctx.fillRect(startPoint[0]* gridXInterval, startPoint[1]*gridYInterval, gridXInterval, gridYInterval);
        ctx.fillRect(endPoint[0]* gridXInterval, endPoint[1]*gridYInterval, gridXInterval, gridYInterval);
		  }
		  
		  var drawPath = function(){
		    for(var x, y, i = 0, j = result.length; i < j; i++) {
					x = result[i][0];
					y = result[i][1];
					ctx.fillStyle = 'blue';
			    ctx.fillRect(x* gridXInterval, y*gridYInterval, gridXInterval, gridYInterval);
				}
		  };
		  
		  var drawSoldiers = function() {
		    for (var i=0; i < mySoldierManager.allSoldiers().length; i++) {
		      drawSoldier(mySoldierManager.allSoldiers()[i]);
		    };
		  };
		  
		  var drawSoldier = function(soldier){
		    x = soldier.getCurrentPosition()[0];
				y = soldier.getCurrentPosition()[1];
				ctx.fillStyle = soldier.getColor();
		    ctx.fillRect(
		      x - soldier.getSize()/2, 
		      y - soldier.getSize()/2, 
		      soldier.getSize(), 
		      soldier.getSize()
		    );
		    // draw the health

		    var barLength = 20
		    //background
		    ctx.fillStyle = 'red'
		    ctx.fillRect(
		      x - barLength / 2,
		      y - 15,
		      barLength,
		      5
		    )
		    ctx.fillStyle = 'rgb(0,255, 0)'
		    ctx.fillRect(
		      x - barLength / 2,
		      y - 15,
		      barLength * soldier.getHealthPercentage(),
		      5
		    )
		  }
		  
		  var drawCorpses = function() {
		    for (var i=0; i < corpses.length; i++) {
		      drawCorpse(corpses[i]);
		    };
		  };
		  
		  var drawBits = function(){
		    for (var i=0; i < bits.length; i++) {
		      var bit = bits[i]
		      if (bit == null)
		        continue
		        
		      if (bit.startTime > frameNum - 5) {
  		      bit.cX += bit.speedX
  		      bit.cY += bit.speedY
		      } else if (bit.startTime < frameNum - 100) {
	          bit = null
	          continue
	        }
		      var opacity =  1 - (frameNum - bit.startTime) / 100;
		      ctx.beginPath();
  		    ctx.fillStyle = 'rgba(255, 0, 0, '+ opacity+')';
          ctx.arc(
            bit.cX, 
            bit.cY,
            2,
            0,
            Math.PI*2,
            true
          );
          ctx.fill();
		    };
		  }
		  
		  var drawCorpse = function(corpse){
		    drawCircle(
          corpse[0],
          corpse[1],
          'rgba(255,0,0,0.1)'
        );
		  };
		  
		  var drawTerrain = function(){
		    for (var i=0; i < terrain.length; i++) {
		      drawCircle(
            terrain[i][0],
            terrain[i][1],
            'brown'
          );
		    };
		  }
		  
		  this.pointCenterXY = function(x, y){
		    return [
		      x * gridXInterval + (gridXInterval/2), 
		      y * gridYInterval + (gridXInterval/2)
		    ]
		  };
		  
		  this.cellFromPosition = function(position){
		    var xIndex = Math.floor( position[0] / gridXInterval )
		    var yIndex = Math.floor( position[1] / gridYInterval )
		    return [xIndex, yIndex];
		  };
		  
		  draw();
		  
		  $(canvas).click(function(evt){
		    if (playing == false || paused == true){
		      return false;
		    }
		    var xIndex = Math.floor( evt.offsetX/gridXInterval )
		    var yIndex = Math.floor( evt.offsetY/gridYInterval )
		    
		    if(nuking){
		      unfortunates = mySoldierManager.withinRange(xIndex, yIndex, nukeRadius)
		      for (var i=0; i < unfortunates.length; i++) {
		        unfortunates[i].takeBullet(100);
		      };
		      return false;
		    };
		    
		    if (grid[yIndex][xIndex] == 1)
		      return false // can't put things on top of each other
		      
		    // check there is money
		    if(money < myTurretManager.cost(currentTurretIndex)){
					$('#notice').text('Not enough money, bozo!')
		      // no money
		      return false
		    }
		    grid[yIndex][xIndex] = 1;
		    // check the global path
		    result = AStar(grid, startPoint, endPoint, "Manhattan");
		    if (result.length == 0){ // fail to connect
		      grid[yIndex][xIndex] = 0;
  		    result = AStar(grid, startPoint, endPoint, "Manhattan");
  		    return false
		    };
		    //check for all the soldiers
		    for (var i=0; i < mySoldierManager.allSoldiers().length; i++) {
		      if (!mySoldierManager.allSoldiers()[i].regeneratePath()) {
		        grid[yIndex][xIndex] = 0;
    		    result = AStar(grid, startPoint, endPoint, "Manhattan");
		        return false;
		      }
		    };
		    highLight = null;
		    myTurretManager.createTurret([xIndex, yIndex]);
	      draw();
		  });
		  
		  $(canvas).mousemove(function(evt){
		    var xIndex = Math.floor( evt.offsetX/gridXInterval )
		    var yIndex = Math.floor( evt.offsetY/gridYInterval )
		    highLight = [xIndex, yIndex];
	    });
	    
	    $(canvas).mouseout(function(evt){
		    highLight = null;
	    });

	  };
	  
	  var Turret = function(position, template, id){
	    var position = position;
	    var id = id;
	    var range = template['range'];
	    var damage = template['damage'];
	    var fireRate = template['fireRate'];
	    var color = template['color'];
	    var tSoldier;
	    
	    this.getPosition = function() {
	      return position;
	    };
	    
	    this.targettedSoldier = function() {
	      return tSoldier;
	    }
	    
	    this.getColor = function(){
				return color;
			}
	    
	    var setTargettedSoldier = function(){
	      tSoldier = soldiersInRange()[0];
	    }
	    
	    this.aimAndFire = function(){
	      setTargettedSoldier();
		    if (tSoldier && (frameNum % fireRate == 0)){
		      firing = true;
		      tSoldier.takeBullet(damage);
		      if (template['hitCallback']){
		        template['hitCallback'](tSoldier, frameNum)
		      }
	      } else {
	        firing = false;
	      }
	    }
	    
	    this.isFiring = function(){
	      return firing;
	    }
	    
	    var soldiersInRange = function(){
	      return mySoldierManager.withinRange(position[0], position[1], range);
	    };
	    
	    this.getDamage = function(){
	      return damage;
	    };
	  }
	  
	  var Soldier = function(startPoint, endPoint, grid, template, id){
	    var self = this;
      // this.xPos;
      // this.yPos;
      var initialHealth = template['health'];
	    var health = initialHealth;
	    var myPath;
	    var pathIndex = 0;
	    var currentPoint;
	    var currentPosition;
	    var id;
	    var deathCallback;
	    var destinationCallback;
	    var nextPoint;
	    var nextPointPosition;
	    var speed = template['speed'];
	    var color = template['color'];
	    var size = template['size'];
			var bounty = template['bounty']
			var template = template;
	    var slowedUntil;
	    currentSpeed = speed;
	    
	    this.move = function(){
	      if(isSlowed()){
	        currentSpeed = speed / 2;
	      } else {
	        currentSpeed = speed;
	      }
	      // kludge
	      if (nextPointPosition[0] > currentPosition[0]){
	        currentPosition[0] += currentSpeed;
	      } else {
	        currentPosition[0] -= currentSpeed;
	      }
	      if (nextPointPosition[1] > currentPosition[1]){
	        currentPosition[1] += currentSpeed;
	      } else {
	        currentPosition[1] -= currentSpeed;
	      }
	      var cell = mygrid.cellFromPosition( currentPosition );
        if (nextPoint == undefined){
          destinationCallback();
          return false
        } else if ( cell[0] == nextPoint[0] && cell[1] == nextPoint[1]) {
	        pathIndex++
          if (pathIndex < myPath.length){
            currentPoint = myPath[pathIndex];
            nextPoint    = myPath[pathIndex + 1];
            if (nextPoint)
    	        nextPointPosition = mygrid.pointCenterXY(nextPoint[0], nextPoint[1]);
          } 
	      }
	    }
	    
	    this.slow = function(myFrameNum){
	      slowedUntil = myFrameNum;
	    }
	    
	    var isSlowed = function(){
	      return slowedUntil && slowedUntil > frameNum
	    }
	    
	    this.getCurrentPosition = function(){
	      return currentPosition;
	    }
	    
	    this.regeneratePath = function(){
	      var newPath = AStar(grid, currentPoint, endPoint, "Manhattan");
		    if (newPath.length == 0){
          return false;
		    } else {
		      pathIndex = 0;
		      myPath = newPath;
		      return true;      
		    };
	    }
	
			this.getColor = function(){
				return isSlowed() ? 'green' : color;
			}
	    
	    // this is the grid coordinate for the soldier
	    this.getCurrentPoint = function(){
	      return currentPoint;
	    }
	    
	    this.onReachDestination = function(callback){
	      destinationCallback = callback;
	    }
	    
	    this.onDie = function(callback){
	      deathCallback = callback;
	    }
	    
	    this.getSize = function(){
	      return size;
	    };
	    
	    this.takeBullet = function(damage) {
	      health -= damage;
	      if ( health <= 0 ){
	        corpses.push(
	          new Corpse(self.getCurrentPosition())
	        )
	        deathCallback();
					incrementKills(bounty);
	      }
	    }
	    
	    this.getHealthPercentage = function(){
	      return health / initialHealth;
	    }
	    
	    var initialise = function(){
	      myPath = AStar(grid, startPoint, endPoint, "Manhattan");
	      currentPoint = myPath[pathIndex];
	      nextPoint = myPath[pathIndex + 1];
	      currentPosition =   mygrid.pointCenterXY(currentPoint[0], currentPoint[1]);
	      nextPointPosition = mygrid.pointCenterXY(nextPoint[0], nextPoint[1]);
	    }
	    
	    initialise();
	  }
	  
	  var bits = [];
		var Corpse = function(position) {
		  var startPosition = position;
		  
	    var i = 5
      while (i) {
        bits.push({
          speedX: 15 - (Math.random() * 30),
          speedY: 15 - (Math.random() * 30),
          cX: position[0],
          cY: position[1],
          startTime: frameNum
        })
        i--;
      }
		};
		
		function GridGenerator(width, height){
			var	floor = Math.floor,
				random = Math.random,
				result = new Array(height);
			for(var	j, i = 0; i < height; i++) {
				result[i] = new Array(width);
				for(j = 0; j < width; j++)
					result[i][j] = 0
			};
			return result;
		};
		
		var kills = 0;
		var grid;  
		var lives = 20;
		var mySoldierManager;
		var myTurretManager;
		var mygrid;
		var regularity = 20; // the speed that new soldiers appear
		var waveLength = 10; // the length of a wave - eg how many soldiers per round
		var soldierCountDown = regularity;
		var waveCountDown = waveLength;
		var speed = 2;
		var health = 100;
		var round = 1;
		var money = 20;
		var frameNum = 0;
		var startPoint =  [3, 0];
    var	endPoint =    [5, 14];
    var currentTurretIndex = 0;
		var nuking = false;
		var paused = false;
		var playing =  false;
		var nukeRadius = 5;
		
		var incrementKills = function(bounty){			
			money += bounty;
			kills++;
      $('#kills').text(kills);
			AttemptToWinGame();
		};
		
		var AttemptToWinGame = function(){
		  if (round == waves.length && waveCountDown == 0 && mySoldierManager.allSoldiers().length == 0){
		    $('#notice').text('YOU WIN!')
  			clearInterval(globalInterval);
  			playing = false;
			}
		}
		
		var loseLife = function(){
		  lives--;
      $('#lives').text(lives);
		}
		
		// wave looks like [soldierType, regularity, wavelength]
		var waves = [
			[0, 30, 10],
			[0, 30, 10],
			[1, 50, 5],
			[0, 15, 10],
			[0, 15, 10],
			[1, 30, 5],
			[0, 10, 10],
			[0, 10, 10],
			[2, 10, 5],
			[0, 15, 5],
			[0, 15, 10],
			[1, 10, 10]
		];
		
		var k = 10;
		var terrain = [];
		while(k > 0){
		 terrain.push( [Math.floor(Math.random() * 15), Math.floor(Math.random() * 15)] );
		 k--
		}
		
		var frameFunction = function(){
      frameNum ++;
      if (lives == 0){
        $('#notice').text('death to you, sucker!!! you are teh suck!!!');
        clearInterval(globalInterval);
        playing = false;
      }
      
      // aim the turrets and fire if possible
      for(var i =0; i < myTurretManager.allTurrets().length; i++){
        var turret = myTurretManager.allTurrets()[i]
        turret.aimAndFire();
      }
      
      if (soldierCountDown > 0){
        soldierCountDown--;
      } else {
        if (waveCountDown > 0){
          waveCountDown--;
        } else {
					if(round <= waves.length){
						$('#notice').text('Round ' + round + ' completed (of '+waves.length+')');
						round++;
						// mark the round number
            $('#round').text(round);
						wave = waves[round - 1];
						waveCountDown = wave[2];
						regularity = wave[1];
						typeIndex = wave[0];
					}
        }
				if (round	<= waves.length){
        	mySoldierManager.createSoldier(typeIndex);
				}
        soldierCountDown = regularity;
      }
      
      // move the soldiers
      for (var i=0; i < mySoldierManager.allSoldiers().length; i++) {
        mySoldierManager.allSoldiers()[i].move();
      };
      
      mygrid.public_draw();
      
      $('#money').text(money);
    }
		
	  $().ready(function(){	    
	    mySoldierManager = new SoldierManager();
	    myTurretManager = new TurretManager();
	    grid = GridGenerator(15, 15);
	    for (var i=0; i < terrain.length; i++) {
	     grid[ terrain[i][1] ][terrain[i][0]] = 1;
	    };
	    mygrid = new Grid('canvas', grid);
	    drawTurretButtons();
	    
	    wave = waves[0];
			waveCountDown = wave[2];
			regularity = wave[1];
			typeIndex = wave[0];
			
			$('#notice').text('RELEASE THE HORDES!!!!');
			playing = true;
	    //  global interval
	    globalInterval = setInterval(frameFunction, 60);
			
			
      $('#pause_button').click(function(evt){
				if(!paused){
        	clearInterval(globalInterval);
					paused = true;
					$('#pause_button').text('Play');
				} else {
					globalInterval = setInterval(frameFunction, 60);
					paused = false;
					$('#pause_button').text('Pause');
				}
      })
	  });
	  
	  var drawTurretButtons = function(){
	    $('#turret_choices').text('')
	    for (var i=0; i < myTurretManager.getTurretTypes().length; i++) {
	      var t = myTurretManager.getTurretTypes()[i];
	      var tbutton = $('<a href="#">').text(myTurretManager.getTurretTypes()[i]['name'])
	      tbutton.data('foo', i)
	      tbutton.click(function(){
	        currentTurretIndex = $(this).data('foo');
 	 	    });
  	    $('#turret_choices').append(tbutton);
	    };
	  }
	  
	  $(window).keydown(function(event) {
      if (event.keyCode == '78') {
         nuking = true;
       }
    });
    
    $(window).keyup(function(event) {
      if (event.keyCode == '78') {
         nuking = false;
       }
    });
  </script>
<style type="text/css" media="screen">
	* {
		font-family: arial;
	}
	a {
	  color: black;
	}
	#notice {
		font-size: 2em;
		text-align: center;
		width: 400px;
		margin-left: 200px;
	}
	#turret_choices a {
    display: block;
    padding: 5px;
    float: left;
	}
	#turret_choices a:hover {
    background: yellow;
	}
	p {
	  clear: left;
	}
</style>
</head>

<body>
	
<div id="notice">Game starting soon</div>

<div style="float:left; width: 200px">
	<p>Lives: <span id="lives"></span></p>
  <p>Round: <span id="round"></span></p>
  <p>Kills: <span id="kills"></span></p>
  <p>Money: <span id="money"></span></p>
  
  <div>
    <h3>Choose your weapons!!!</h3>
    <div id="turret_choices"></div>
		<p><a href="#" id="pause_button">Pause</a></p>
  </div>
</div>
<canvas id="canvas" height="400" width="400"></canvas>
</body>
</html>